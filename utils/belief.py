import numpy as np
from utils.network import initialize_network

def initialize_beliefs(P: int, Q: int, A: float, B: float, **kwargs) -> tuple[np.ndarray, np.ndarray]:
    """ The distribution of possible beliefs is captured by the beta distribution with shape params A and B.

    The objective truth is the mean of this beta distribution, which is A/(A+B).

    Noisy private information of each person in the network is generated by random draws from this beta distribution. For example, person i's private information regarding the issue is (x_i1, x_i2, x_i3,..., x_iQ). These random draws are also viewed as the observations of person i.

    Initial beliefs of each person is the mean the noisy private information. Person i's initial belief b1_i is the arithmetic mean of (x_i1, x_i2, x_i3,..., x_iQ). In other words, the initial belief of each person is the arithmetic mean of her observations.

    The function will first generate a 1D array of initial beliefs of each person in the network. Then, the function will find the indices of the fanatics, i.e. the people who have the highest initial belief (because beliefs are generated using the beta distribution, high beliefs are likely not 1 but rather close to 1). The indices of the fanatics will be stored in the results dictionary.

    Params:
        P (int): The number of people in the network.
        Q (int): The number of random draws.
        A (float): The shape parameter of the beta distribution.
        B (float): The shape parameter of the beta distribution.
        **kwargs: The keyword arguments
            num_fanatics (int): The number of fanatics in the network. Default is 0.

    Returns:
        b: a 1D NumPy array representing the initial beliefs of each person in the network
        fanatics: a 1D NumPy array representing the indices of the fanatics
    """
    num_fanatics = kwargs.get('num_fanatics', 0)
    fanatics_scheme = kwargs.get('fanatics_scheme', 'none')
    # Generate a 1D array of initial beliefs of each person in the network; if `P` is large enough, the average of the initial beliefs should be close to the objective truth
    b = np.random.beta(a=A, b=B, size=P)
    fanatics = []
    if num_fanatics == 0 or fanatics_scheme == 'none':
        return b, fanatics
    else:
        # Find the indices of the fanatics
        if fanatics_scheme == 'max':
            fanatics = np.argsort(b)[::-1][:num_fanatics]
            for i in fanatics:
                b[i] = 1
        elif fanatics_scheme == 'min-max':
            # Half of the fanatics have the lowest initial beliefs and the other half have the highest initial beliefs
            max_fanatics = np.argsort(b)[::-1][:num_fanatics//2]
            min_fanatics = np.argsort(b)[:num_fanatics//2]
            fanatics = np.concatenate(
                (max_fanatics, min_fanatics), axis=0)
            for i in max_fanatics:
                b[i] = 1
            for i in min_fanatics:
                b[i] = 0
        elif fanatics_scheme == 'mean':
            # Fanatics are those whose beliefs are the closest to the mean of the initial beliefs
            fanatics = np.argsort(np.abs(b-np.mean(b)))[:num_fanatics]
            b_mean = np.mean(b)
            for i in fanatics:
                b[i] = b_mean
    return b, fanatics

def test_initialize_beliefs():
    np.random.seed(42)
    p = 10
    q = 1
    beta_shape1 = 0.005
    beta_shape2 = 0.005
    num_fanatics = 3
    b, fanatics = initialize_beliefs(
        P=p, Q=q, A=beta_shape1, B=beta_shape2, num_fanatics=num_fanatics)
    print(b)
    print(fanatics)

# test_initialize_beliefs()


def revise_beliefs(network: np.ndarray, prev_b: np.ndarray, P: int, N: int, beta: float, **kwargs) -> np.ndarray:
    """ 
    Revise the beliefs of each person in the network.

    From the "saying is believing" result, we know that the equilibrium utterance of each person is her belief. In other words, at time t, a person i's equilibrium utterance a_i is equal to her belief b_i.

    Also from the "saying is believing" result, the equilibrium utterances of her associates also represent their beliefs. In other words, at time t, a person j (an associate of person i) is also expected to utter a_j = b_j.

    Update rule: the belief of person i at time t is her belief at time t-1 times 1/(1+num_friends times the social dissonance parameter, beta) plus the sum of her associates' beliefs weighted by beta/(1+num_friends times beta).

    Params:
        prev_b (np.ndarray): The previous beliefs of each person in the network
        network (np.ndarray): The network of people
        N (int): The number of friends each person has
        beta (float): The social dissonance parameter
        **kwargs: The keyword arguments
            fanatics (list): The indices of the fanatics. Default is an empty list.

    Returns:
        revised_b: a 1D NumPy array representing the revised beliefs of each person in the network
    """
    fanatics = kwargs.get('fanatics', [])
    if fanatics is None:
        fanatics = []
    P = prev_b.shape[0]
    revised_b = np.zeros(P)
    for i in range(P):
        if i in fanatics:
            revised_b[i] = prev_b[i]
        else:
            friends = np.where(network[i] == 1)[0]
            revised_b[i] = prev_b[i] * \
                (1/(1+N*beta)) + np.sum(prev_b[friends] * beta/(1+N*beta))
    return revised_b

def test_revise_beliefs():
    np.random.seed(42)
    p = 20
    n = 5
    q = 1
    beta_shape1 = 0.005
    beta_shape2 = 0.005
    num_fanatics = 3
    social_dissonance = 0.1
    init_network = initialize_network(P=p, N=n)
    init_b, fanatics = initialize_beliefs(
        P=p, Q=q, A=beta_shape1, B=beta_shape2, num_fanatics=num_fanatics)
    print("Initial fanatics:", fanatics)
    b_fanatics_before = init_b[fanatics]
    revised_b = revise_beliefs(network=init_network, prev_b=init_b,
                               P=p, N=n, beta=social_dissonance, fanatics=fanatics)
    b_fanatics_after = revised_b[fanatics]
    print("Beliefs of fanatics before revising:", b_fanatics_before)
    print("Beliefs of fanatics after revising:", b_fanatics_after)

# test_revise_beliefs()


def calculate_enlightenment(init_b: np.ndarray, final_b: np.ndarray) -> float:
    """ Calculate the enlightenment of the network of people based on the beliefs of each person.

    Params:
        network (np.ndarray): The network of people
        init_b (np.ndarray): The initial beliefs of each person in the network
        final_b (np.ndarray): The final beliefs of each person in the network

        Returns:
            (float): The enlightenment of the network of people
    """
    init_ig = np.sum(np.abs(init_b-np.mean(init_b)))
    equi_ig = np.sum(np.abs(final_b-np.mean(init_b)))
    return (init_ig - equi_ig) / init_ig
